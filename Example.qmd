---
title: "Example"
author: "Gregor Steiner"
date: last-modified
editor: visual
theme: cosmo
toc: true  
number-sections: true
colorlinks: true
highlight-style: pygments
format:
  html: 
    code-fold: true
    code-tools: true
    html-math-method: katex
    self-contained: true
bibliography: references.bib
---

# Simulate Data

First, we simulate data based on a simple example with a binary treatment $X$. The outcome $Y$ given an intervention on $X$ is distributed normally, that is 
$$Y | \text{do}(X = x) \sim N(\beta_X x, \sigma_Y^2),$$
where we set $\beta_X = 1$. The confounder $Z$ also follows a normal distribution.

```{r message=FALSE, warning=FALSE}
library(causl)

forms <- list(Z ~ 1, 
              X ~ Z,
              Y ~ X, 
              ~ X)

pars <- list(Z = list(beta = 1, phi = 1),
             X = list(beta = c(0, 1), phi = 1),
             Y = list(beta = c(0, 1), phi = 1),
             cop = list(beta = c(0, 1), phi = 1))

set.seed(12)
n <- 1e3
dat <- rfrugalParam(n, formulas = forms, pars = pars, 
                    family = list(1, 5, 1, 1), careful=FALSE)


```




# Maximum Likelihood

Below, I manually implement the maximum likelihood estimation as described in @evans_didelez_2023. We optimize the log-likelihood via a simple grid search. And indeed, we get $\widehat{\beta_X} = 1$.

```{r}
likl <- function(beta, sigma, beta_z, sigma_z, phi){
  with(dat, {
    # marginal structural model
    p_Y_X <- dnorm(Y, beta * X, sigma, log = TRUE) |> sum()
    
    # past
    p_ZX <- dnorm(Z, beta_z, sigma_z, log = TRUE) |> sum() +
      dnorm(X, log = TRUE) |> sum()
    
    # copula
    cop <- copula::normalCopula(param = c(phi))
    u <- matrix(NA, nrow = nrow(dat), ncol = 2)
    u[, 1] <- pnorm(Y, beta * X, sigma)
    u[, 2] <- pnorm(Z, beta_z, sigma_z)
    copd <- copula::dCopula(cop, u = u, log = TRUE) |> sum()
    
    # return sum (since we did all calculations on a log-scale)
    return(p_Y_X + p_ZX + copd)
    })
}

beta.seq <- seq(0.5, 1.5, 0.1)
sigma.seq <- seq(0.8, 1.2, 0.1)
phi.seq <- seq(-0.5, 0.5, 0.1)
grid <- expand.grid(beta = beta.seq, sigma = sigma.seq,
                    beta_z = beta.seq, sigma_z = sigma.seq,
                    phi = phi.seq)

res <- apply(grid, 1, function(x) likl(x[1], x[2], x[3], x[4], x[5]))
grid[which.max(res), ]


```


Below, we use the implementation of Robin Evans to get a more precise result.

```{r}
fit <- fitCausal(dat, formulas = list(Y ~ X, Z ~ 1, ~ X),
                 family = c(1, 1, 1), control=list(maxit=2e4, newton=TRUE))
fit
```

Below, we perform a naive outcome regression, where we obtain a clearly biased estimate of $\beta_X$.

```{r}
lm(Y ~ X, data = dat) |> confint()
```




